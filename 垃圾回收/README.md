# 垃圾回收

## V8 垃圾回收机制

V8 的垃圾回收策略主要基于**分代式**垃圾回收机制。

在 V8 中，依据**对象的存活时间**，将内存分为**新生代**和**老生代**两代。**新生代**中的对象为存活时间**较短**的对象，老生代的对象为存活时间**较长**的对象。

V8 堆的整体大小 = 新生代内存空间 + 老生代内存空间

新生代内存空间和老生代内存空间采用不用的垃圾回收策略。

### 新生代垃圾回收

在分代的基础上，新生代中的对象主要通过 **Scavenge** 算法进行垃圾回收。在 **Scavenge** 的具体实现中，主要采用 **Cheney** 算法。

**Cheney** 算法是一种采用复制的方式实现垃圾回收算法。它将堆内存一分为二，每一部分空间成为 **semispace**。在这两个 **semispace** 空间中，只有一个处于使用中【FROM 空间】，另一个处于闲置状态【TO 空间】。当我们分配对象时，先是在 FROM空间 中进行分配。当开始垃圾回收时，会先检查 FROM空间中的存活对象，这些存活对象将被复制到 TO空间中，而非存活对象占用的空间将会被释放。完成复制后，FROM空间 和 TO空间 **角色互换**【又称**翻转**】。简言之，在垃圾回收的过程中，就是通过将存活对象在两个 **semispace** 空间进行复制。

**Scavenge** 的缺点是只能使用堆内存中的一半，这是有划分空间和复制机制所决定的。但 **Scavenge** 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。

由于 **Scavenge** 是典型的牺牲空间换取时间的算法，所以无法大规模应用到所有的垃圾回收中。但可以发现，**Scavenge** 非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。

当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代的过程成为**晋升**。

对象晋升的条件：
1. 对象是否经历过 **Scavenge** 回收；
1. To空间的内存占用比【**25%**】超过限制；

### 老生代垃圾回收

V8 老生代中主要采用了**Mark-Sweep**【**标记清除**】 和 **Mark-Compact** 相结合的方式进行垃圾回收。

#### Mark-Sweep 分为**标记**和**清除**两个阶段。

Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只**清除没有被标记的对象**。

-----
JavaScript 中最常用的垃圾收集方式是**标记清除**（mark-and-sweep）。垃圾收集器在运行的时候会给存储在内存中的所有变量加上标记。然后，他会去掉环境中的变量以及被环境中的变量引起的变量标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问这些变量了。最后垃圾收集器完成**内存清除**工作，**销毁**那些**带有标记的值**并回收它们所占用的内存空间。

-----

**Scavenge** 中只复制活着的对象，而**Mark-Sweep**只清理死亡对象。**活对象**在新生代中只占小部分，**死对象**在老生代中只占小部分。这是两种回收方式能高效处理的原因。

**Mark-Sweep** 最大的问题是进行一次标记清除后，内存空间会出现**不连续**状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况【**需要一片很大连续内存空间**】，这时所有的碎片空间都无法完成此次分配，就会提前出发垃圾回收，而这次回收是不必要的。

为解决 **Mark-Sweep** 的内存碎片问题，**Mark-Compact**【标记整理】 被提出来。它们的差别在于对象被标记为死亡后，在整理的过程中，将活着的对象往一端挪动【将活对象移动到一端，将死对象移动到另一端】，移动完成后，直接清理掉边界外的内存。

完成移动后，就可以直接清除最右边的存活对象后面的内存区域完成回收。

这里将 **Mark-Sweep** 和 **Mark-Compact** 结合着介绍，不仅仅是因为两种策略是递进关系，在 V8 的回收策略中两者是结合使用的。

3种垃圾回收算法的的简单对比

| 回收算法 | Mark-Sweep | Mark-Compact | Scavenge |
|:---|:---|:---|:---|
|速度|中等|最慢|最快|
|空间开销|少(有碎片)|少(无碎片)|双倍空间(无碎片)|
|是否移动对象|否|是|是|

在 **Mark-Sweep** 和 **Mark-Compact** 之间，由于 **Mark-Compact** 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用**Mark-Sweep**，在空间不足以对从新生代中**晋升**过来的对象进行分配时才使用**Mark-Compact**。

#### Incremental Marking

为了避免出现 Javascript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3中基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为"**全停顿**"(stop-the-world)。在 V8 的垃圾**分代式**垃圾回收中，一次小垃圾回收只收集**新生代**，由于新生代默认配置的较小，且其存活对象通常较少，所以即使它是全停顿的影响也不大。但 V8 老生代通常配置的比较大，且存活对象比较多，全堆垃圾回收的标记（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。

为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原本要一口气停顿完成的动作改成增量标记（incremental marking），也就是拆分为许多小"进步"，每做完一"进步"就让 Javascript 应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行知道标记阶段完成。

V8 在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到本来的1/6左右。

V8 后续还引入了**延迟清理**(lazy sweeping) 与 **增量式整理**(incremental compaction)，让清理与整理动作也变成增量式的。同时还计划引入**并行标记**和**并行清理**，进一步利用多核性能降低每次停顿时间。


## 小结

从 V8 的自动垃圾回收机制的设计角度可以看到，V8 对内存使用进行进行限制的缘由。新生代设计为一个较小的内存空间是合理的，而老生代空间过大对于垃圾回收并无特别意义。V8 对内存限制的设置对于 Chrome 浏览器这种每个选项卡页面使用一个 V8 实例而言，内存的使用是绰绰有余的。对于 Node 编写服务端来水，内存限制并不影响正常场景下的使用。但是对于 V8 的垃圾回收特点和 Javascript 在单线程上执行来说，垃圾回收是影响性能的因素之一。想要高性能的执行效率，需要注意让垃圾回收尽量少地进行，尤其是全堆垃圾回收。

以 Web 服务器中的会话实现为例，一般通过内存来存储，但在访问量大的时候，会导致老生代中存活对象骤增，不仅造成清理/整理过程费时，还会造成内存紧张，甚至溢出。

参考链接：
-- 朴灵 《深入浅出 Nodejs》第五章
